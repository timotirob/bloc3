= TP - Authentification Web : Sessions et Persistance
:author: Timoth√©e Robert
:revdate: 2025-11-17
:version-label: Version ESM, revue et compl√©t√©e
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js
:imagesdir: images

== Introduction

Nous avons vu comment authentifier un utilisateur avec un mot de passe hach√© et sal√©.
Cependant, le protocole **HTTP est "stateless"** (sans √©tat). Une fois l'authentification r√©ussie sur une requ√™te, le serveur "oublie" l'utilisateur pour la requ√™te suivante.

Comment, d√®s lors, donner acc√®s √† des ressources prot√©g√©es sans redemander le mot de passe √† chaque clic ?

C'est le r√¥le de la **gestion de session**. Aujourd'hui, nous √©tudions le m√©canisme de session web "classique" (stateful).
Par la suite, nous aborderons les tokens (JWT), OAuth2, et l'authentification √† double facteur.

[NOTE]
.Complexit√© des m√©thodes d'authentification
====
image::modesAuth.png[Tableau des choix d'authentification]

Comme le montre ce sch√©ma, la gestion de session est le point de d√©part, et la complexit√© augmente avec des solutions comme JWT ou OAuth.
====

=== Analyse pr√©liminaire

.Question de recherche :
Pourquoi les cookies "simples" (contenant directement des informations utilisateur) et les param√®tres d'une requ√™te GET (ex: `?user=tim&role=admin`) ne sont-ils **absolument pas** appropri√©s pour g√©rer une authentification ?

== Fonctionnement d'une session HTTP

=== Principes

HTTP est sans √©tat, mais on peut utiliser ses en-t√™tes (`headers`) et les **cookies** pour simuler un √©tat.
* **En-t√™tes (Headers) :** Informations de m√©tadonn√©es qui voyagent avec chaque requ√™te et r√©ponse.
* **Cookies :** Petits morceaux de donn√©es que le serveur demande au client (navigateur) de stocker.

Le flux de base est le suivant :

image::sessionsCookies.png[Flux de session HTTP]

1.  Le client demande une page.
2.  Le serveur, dans sa r√©ponse, inclut un en-t√™te `Set-Cookie: session-id=12345;`. Le navigateur stocke ce cookie.
3.  Pour toutes les requ√™tes suivantes vers *le m√™me domaine*, le navigateur inclut automatiquement un en-t√™te `Cookie: session-id=12345;`.
4.  Le serveur lit cet ID, recherche la session "12345" dans sa base de donn√©es et "sait" ainsi qui est l'utilisateur.

=== Exercice : Examen d'un cookie

.  Dans Chrome, allez sur une page (ex: google.fr) et ouvrez la console (F12).
.  Dans la console, tapez le code suivant :
+
[source,javascript]
----
const maDate = new Date();
// Ajoute 30000 millisecondes (30 secondes) √† la date actuelle
maDate.setTime(maDate.getTime() + 30000);
// Cr√©e un cookie c√¥t√© client
document.cookie = "monCookie=Totoro; expires=" + maDate.toUTCString() + ";";
----
+
.  *Analyse :*
.. Que fait ce code ?
.. Allez dans l'onglet `Application` -> `Stockage` -> `Cookies`. Que constatez-vous ?
.. Combien de temps avez-vous pour voir ce cookie avant qu'il ne disparaisse ?
.  *Visualisation (optionnel) :*
.. Rechargez la page (F5) et allez dans l'onglet `R√©seau (Network)`.
.. Cliquez sur la premi√®re requ√™te (le nom de la page).
.. Dans les en-t√™tes (`Headers`), cherchez `Cookie` dans la section `Request Headers`. Vous devriez y voir votre cookie "monCookie=Totoro" √™tre envoy√© au serveur.

=== Donn√©es de session

La diff√©rence fondamentale est simple :

* Le **cookie** est stock√© **c√¥t√© client** (navigateur).
* Les **donn√©es de session** (qui est l'utilisateur, son r√¥le, etc.) sont stock√©es **c√¥t√© serveur** (en m√©moire, dans un fichier, ou en BDD).

Le cookie de session ne contient qu'un **identifiant al√©atoire et d√©nu√© de sens** (le `session-id`). Il sert uniquement de "cl√©" pour retrouver les vraies donn√©es c√¥t√© serveur. C'est pour cela que ce m√©canisme est dit **"stateful"** (le serveur maintient un √©tat).

=== Authentification vs. Autorisation

.Question de cours :
Rappelez en une phrase la diff√©rence fondamentale entre **l'authentification** et **l'autorisation**.

[TIP]
.R√©ponse
====
* **Authentification** : Prouver qui vous √™tes (ex: login + mot de passe). C'est le "contr√¥le d'identit√©".
* **Autorisation** : V√©rifier ce que vous avez le droit de faire (ex: un "admin" peut voir le panel, un "user" ne peut pas). Ce sont les "permissions".
====

=== Exercice : Utilisation de cURL (Challenge)

Cet exercice (bas√© sur un challenge PHP) d√©montre parfaitement la persistance de session.
.  Installez les deux fichiers PHP (`session.php` et `supprime.php`), fournis dans le r√©pertoire sources, dans votre r√©pertoire `www` de Laragon.
.  D√©marrez Laragon.
.  Avec votre navigateur, visitez les URL dans cet ordre :
.. `http://localhost/session.php` (Affiche "Je ne sais pas qui vous √™tes")
.. `http://localhost/session.php?nom=Django` (Affiche "Je sais que vous vous appelez Django")
.. `http://localhost/session.php` (Affiche "Je sais que vous vous appelez Django")
.  Le serveur se "souvient" de vous gr√¢ce √† la session.
.  **Votre challenge :** Reproduisez ce sc√©nario exact en ligne de commande avec `cURL`. (Indice : `cURL` ne sauvegarde pas les cookies par d√©faut, il faudra utiliser les options `-c` (cookie-jar) et `-b` (cookie) pour simuler le navigateur).

== Partie 2 : Impl√©mentation avec NodeJS et `express-session`

Nous allons impl√©menter ce m√©canisme dans notre application d'authentification.

=== √âtape 1 : Installation

Nous avons besoin de `express-session` pour g√©rer les sessions.

[source,bash]
----
# express-session g√®re la session
# session-file-store (optionnel) pour stocker les sessions dans des fichiers
npm install express-session session-file-store
----

[NOTE]
.Nettoyage des d√©pendances
====
Dans le document original (ann√©e derni√®re), `cookie-parser` et `body-parser` √©taient list√©s.
* `body-parser` est **obsol√®te**. `express.json()` et `express.urlencoded()` sont int√©gr√©s √† Express.
* `cookie-parser` n'est **plus n√©cessaire** pour `express-session` depuis la version 1.5.0. La librairie g√®re les cookies elle-m√™me.
====

=== √âtape 2 : D√©marrage express (100% ESM)

Voici le code de d√©marrage d'un `server.js` 100% ESM, nettoy√© et corrig√©.

[source,javascript]
----
// --- Imports des modules ---
import express from 'express';
import session from 'express-session';
// import mysql from 'mysql2'; // Plus tard, pour stocker en BDD
import path from 'path';

// --- Imports de nos modules (du TP pr√©c√©dent) ---
// import { verifieMdp } from './verifieMdp.mjs';
// import { sha512 } from './hashPassword.mjs';

// --- Configuration initiale ---
const app = express();
const port = 3000;

// Syntaxe ESM moderne pour __dirname
const __dirname = import.meta.dirname;

// --- Middlewares ---
app.use(express.json()); // Pour parser le JSON
app.use(express.urlencoded({ extended: true })); // Pour parser les formulaires
app.use(express.static(path.join(__dirname, 'static'))); // Servir les fichiers statiques (CSS, etc.)
----

=== √âtape 3 : Cr√©ation et configuration de la session

Nous ajoutons `express-session` comme un middleware. Il doit √™tre plac√© **avant** toutes les routes qui en ont besoin.

[source,javascript]
----
// ... (suite du server.js) ...

app.use(session({
  // 'secret' est utilis√© pour signer le cookie de session
  // NE PAS le hardcoder en production ! Doit venir d'un .env
  secret: 'les SIO font toujours dodo',

  // 'name' est le nom du cookie
  name: 'monCookieDeSession',

  // Ne pas sauvegarder la session si elle n'est pas modifi√©e
  resave: false,

  // Ne pas cr√©er de session pour un utilisateur non-authentifi√©
  saveUninitialized: false,

  cookie: {
    // Le cookie ne sera pas accessible par le JS c√¥t√© client (s√©curit√© XSS)
    httpOnly: true,
    // Mettre 'true' en production (n√©cessite HTTPS)
    secure: false,
    // Dur√©e de vie du cookie (ex: 30 secondes pour tester)
    maxAge: 30000
  }
}));

// --- D√©marrage du serveur ---
app.listen(port, () => {
  console.log(`Serveur d√©marr√© sur http://localhost:${port}`);
});
----

[IMPORTANT]
.Critiques de S√©curit√© et Bonnes Pratiques
====
1.  **Secret :** Le `secret` hardcod√© est une faille de s√©curit√©. S'il est d√©couvert, un attaquant peut forger des ID de session. Ce secret DOIT provenir d'un fichier `.env` et √™tre long et al√©atoire (`process.env.SESSION_SECRET`).
2.  **`resave: false` :** Tr√®s bonne pratique. Cela √©vite de r√©-enregistrer la session en BDD √† chaque requ√™te si rien n'a chang√©.
3.  **`saveUninitialized: false` :** Tr√®s bonne pratique. Cela √©vite de polluer le stockage de sessions avec des sessions vides pour les visiteurs anonymes (important pour le RGPD).
4.  **`cookie.secure: true` :** Doit √™tre mis √† `true` en production. Cela force le cookie √† n'√™tre envoy√© que sur une connexion HTTPS, emp√™chant son interception.
5.  **Stockage M√©moire :** Par d√©faut, `express-session` stocke les sessions en m√©moire vive. C'est mauvais pour la production :
* Les sessions sont perdues √† chaque red√©marrage du serveur.
* Cela ne fonctionne pas si vous avez plusieurs serveurs (load balancing).
* Cela peut saturer la m√©moire (fuite de m√©moire).
====

=== √âtape 4 : Analyse et utilisation de la session

Une fois le middleware `session` activ√©, un objet `req.session` est **automatiquement ajout√©** √† chaque requ√™te. Nous pouvons lire et √©crire des donn√©es dedans.

[source,javascript]
----
// ... (√† ajouter avant app.listen) ...

app.get('/compteur', (requete, resultat) => {
  // On v√©rifie si la propri√©t√© 'compteur' existe dans la session
  // Si non, on l'initialise √† 0. Puis on l'incr√©mente.
  requete.session.compteur = (requete.session.compteur || 0) + 1;

  // On peut lire l'ID de session
  const idSession = requete.sessionID;

  // On peut lire les cookies (n√©cessitait cookie-parser,
  // mais l'ID de session est dans le cookie sign√©)
  console.log(requete.cookies); // Affiche les cookies non-sign√©s

  resultat.send(`
    <h1>Bonjour les rigolos</h1>
    <p>Vous √™tes venus ${requete.session.compteur} fois.</p>
    <p>Votre ID de session est : ${idSession}</p>
  `);
});
----

[TIP]
.Am√©lioration du code
====
Le code original (`let compteur = typeof requete.session.compteur === "undefined" ? ...`) est fonctionnel mais verbeux.
La ligne :
`requete.session.compteur = (requete.session.compteur || 0) + 1;`
...est une mani√®re plus idiomatique et concise d'initialiser et d'incr√©menter un compteur en JavaScript.
====

=== √âtape 5 : Destruction d'une session

Pour d√©connecter un utilisateur, on utilise `req.session.destroy()`.

[source,javascript]
----
app.get('/logout', (requete, resultat) => {
  requete.session.destroy((err) => {
    if (err) {
      return resultat.send("Erreur lors de la d√©connexion");
    }
    // Optionnel : effacer le cookie c√¥t√© client
    resultat.clearCookie('monCookieDeSession');
    resultat.send("Session d√©truite !");
  });
});
----

== Partie 3 : Lier l'Authentification et la Session

L'exercice "√Ä faire" du document pr√©c√©dent est maintenant notre objectif principal. Nous allons lier l'authentification (TP pr√©c√©dent) √† la session (ce TP).

=== √âtape 1 : Plugguer l'authentification

Reprenez votre route `POST /login` (ou `POST /auth/login` si vous avez refactoris√©).

.Au lieu de :
[source,javascript]
----
// ... v√©rification du mot de passe ...
if (isMatch) {
  res.send(`Connexion r√©ussie ! Bienvenue ${utilisateur.login}`);
}
----

.Faites ceci :
[source,javascript]
----
// ... v√©rification du mot de passe ...
if (isMatch) {
  // ON STOCKE LES DONN√âES DANS LA SESSION
  requete.session.loggedin = true;
  requete.session.username = utilisateur.login;
  requete.session.userId = utilisateur.id; // Tr√®s important

  // On redirige vers la page prot√©g√©e
  res.redirect('/maison');
} else {
  // ...
}
----

=== √âtape 2 : Cr√©er une route prot√©g√©e

Ajoutons la route `/maison` (ou `/profil`) qui v√©rifie si l'utilisateur est connect√©.

[source,javascript]
----
app.get('/maison', (requete, resultat) => {
  // Si l'utilisateur est logg√©
  if (requete.session.loggedin) {
    // Affiche l'identifiant
    resultat.send(`
      <h1>Bienvenue de nouveau, ${requete.session.username} !</h1>
      <p>Votre Id de session est : ${requete.sessionID}</p>
      <a href="/logout">Se d√©connecter</a>
    `);
    console.log(requete.session.cookie);
  } else {
    // Non logg√©
    resultat.status(401).send('<a href="/login">Identifiez-vous pour visualiser la page</a>');
  }
});
----

.Question Pi√®ge (du TP) :
Dans la route `/maison`, on voit `loggedin`, `username`, `cookie` et `id` (ou `sessionID`). Lesquels sont automatiques et lesquels sont cr√©√©s par nous ?

.R√©ponse :
* **Automatiques (g√©r√©s par `express-session`) :** `cookie` (l'objet cookie) et `sessionID` (l'ID unique).
* **Manuels (cr√©√©s par nous) :** `loggedin` et `username`. Ce sont de simples propri√©t√©s que nous ajoutons √† l'objet `req.session`.

== Partie 4 : Persistance des Sessions (Stores)

Le stockage en m√©moire par d√©faut est une mauvaise pratique. Nous devons rendre les sessions persistantes.

=== Stockage de session dans un fichier (session-file-store)

On peut stocker nos sessions dans des fichiers JSON sur le serveur.

1.  **Installation :** `npm install session-file-store`
2.  **Configuration :**

[source,javascript]
----
// ... imports ...
import session from 'express-session';
import FileStore from 'session-file-store';

const FileStoreSession = FileStore(session);

// ... app.use(express...) ...

// Options pour le stockage fichier
const fileStoreOptions = {
  path: './sessions',         // R√©pertoire de stockage (cr√©ez-le !)
  reapInterval: 3600,         // Nettoyage des vieilles sessions (toutes les heures)
  ttl: 180000                 // Dur√©e de vie d'une session (3 min)
};

// Configuration du middleware session AVEC un store
app.use(session({
  secret: 'les SIO font toujours dodo', // DOIT venir d'un .env
  store: new FileStoreSession(fileStoreOptions),
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 180000, // Doit correspondre √† 'ttl'
    httpOnly: true,
    secure: false // Mettre √† 'true' en production (HTTPS)
  }
}));
----

.Questions (du TP) :
1.  **Q1 :** Identifiez-vous. Que contient le fichier de session cr√©√© dans le dossier `./sessions` ? (R√©ponse : un objet JSON contenant les donn√©es de session, y compris le compteur, `loggedin`, etc.).
2.  **Q2 (Champion) :** Si vous fermez le navigateur et le rouvrez, vous √™tes toujours connect√© (tant que le cookie `maxAge` n'a pas expir√©). Pourquoi ? (R√©ponse : Contrairement au cookie de session par d√©faut, le `maxAge` que nous avons d√©fini cr√©e un cookie *persistant* sur le disque du client). Au bout de combien de temps devez-vous vous r√©-identifier ? (R√©ponse : Au bout de 3 minutes, `maxAge: 180000`).
3.  **Q3 :** Connectez-vous avec le m√™me utilisateur sur Chrome et Firefox. Combien de sessions (fichiers) y a-t-il ? (R√©ponse : Deux. Une session est li√©e √† un navigateur, pas √† un utilisateur. Une session ne peut pas √™tre partag√©e par plusieurs utilisateurs).

=== Stockage de session dans une base de donn√©es MySQL

C'est la m√©thode la plus courante en production.

[CAUTION]
.Note P√©dagogique : `mysql` vs `mysql2`
====
Le document original sugg√®re d'installer et d'utiliser l'ancien package `mysql` car la configuration avec `mysql2/promise` √©tait jug√©e "p√©nible".

C'est une **mauvaise pratique** en 2025. Jongler avec deux drivers (l'ancien `mysql` et le moderne `mysql2`) est source de confusion et de probl√®mes.

La **bonne m√©thode** est d'utiliser un "store" compatible avec `mysql2`. Le plus simple est `connect-mysql2`.
====

==== Solution Moderne avec `connect-mysql2` (Recommand√©e)

1.  **Installation :** `npm install connect-mysql2`
2.  **Configuration :** Nous r√©utilisons le `pool` de connexion du TP pr√©c√©dent.

[source,javascript]
----
// ... imports ...
import session from 'express-session';
import MySQLStore from 'connect-mysql2';
import mysql from 'mysql2/promise'; // Notre pool de connexion existant

// (1) Options de la BDD (celles de votre .env)
const dbOptions = {
  host: 'localhost',
  user: 'nodeJs',
  password: 'test',
  database: 'nodemysql'
};

// (2) Cr√©er le pool de connexion pour notre *application*
const connectionPool = mysql.createPool(dbOptions);

// (3) Cr√©er le store de session
const MySQLSessionStore = MySQLStore(session);
// On passe le pool de connexion au store
const sessionStore = new MySQLSessionStore({}, connectionPool);

// (4) Configurer le middleware de session
app.use(session({
  secret: 'les SIO font toujours dodo',
  store: sessionStore, // On utilise notre store MySQL
  resave: false,
  saveUninitialized: false,
  cookie: {
    maxAge: 180000, // 3 minutes
    httpOnly: true,
    secure: false
  }
}));
----

.Questions (du TP) :
1.  **Q4 :** O√π est stock√©e la session ? (R√©ponse : Dans une nouvelle table `sessions` cr√©√©e automatiquement dans la BDD `nodemysql`).
2.  **Q4 (suite) :** Ouvrez un navigateur et loggez-vous. Ouvrez un autre navigateur en navigation priv√©e et allez sur `/compteur`. Qu'en concluez-vous ? (R√©ponse : Le premier navigateur a une session authentifi√©e, stock√©e en BDD. Le second a une session anonyme (ou pas de session du tout, gr√¢ce √† `saveUninitialized: false`), il n'a pas acc√®s aux donn√©es de l'autre).

=== Stockage de session via un ORM (Sequelize)

Si votre application utilise d√©j√† l'ORM Sequelize, vous pouvez l'utiliser pour stocker les sessions.

1.  **Installation :** `npm install express-session-sequelize sequelize` (et `mysql2`)
2.  **Configuration :**

[source,javascript]
----
// ... imports ...
import session from 'express-session';
import { Sequelize } from 'sequelize';
import SequelizeStore from 'express-session-sequelize';

// (1) Initialiser Sequelize (connexion BDD)
const sequelize = new Sequelize('nodemysql', 'nodeJs', 'test', {
  host: 'localhost',
  dialect: 'mysql'
});

// (2) Cr√©er le constructeur de store
const SequelizeSessionStore = SequelizeStore(session.Store);

// (3) Cr√©er le store
const sessionStore = new SequelizeSessionStore({
  db: sequelize, // On passe l'instance de Sequelize
  tableName: 'Sessions', // Nom de la table
  checkExpirationInterval: 15 * 60 * 1000, // Nettoyage toutes les 15 min
  expiration: 180000 // Expire apr√®s 3 minutes
});

// (4) Configurer le middleware
app.use(session({
  secret: 'les SIO font toujours dodo',
  store: sessionStore,
  resave: false,
  saveUninitialized: false,
  cookie: { maxAge: 180000 }
}));

// (5) IMPORTANT : Synchroniser le mod√®le avec la BDD
// Cr√©e la table 'Sessions' si elle n'existe pas
sessionStore.sync();
----

.Questions (du TP) :
1.  **Q5 :** Lancez l'application (apr√®s avoir supprim√© l'ancienne table `sessions`). Quel message s'affiche ? (R√©ponse : Sequelize logue `Executing (default): CREATE TABLE IF NOT EXISTS...`). Une nouvelle table `Sessions` (avec un 'S' majuscule par d√©faut) est cr√©√©e.
2.  **Q5 (suite) :** Attendez le timeout (3 minutes). La session est-elle purg√©e de la BDD ? (R√©ponse : Oui, le param√®tre `checkExpirationInterval` lance un "ramasse-miettes" qui supprime les sessions expir√©es).

== Partie 5 : Synth√®se et Bilan des Menaces sur les Sessions (OWASP)

La session est un √©l√©ment de s√©curit√© critique. Si un attaquant vole un ID de session, il vole l'identit√© de l'utilisateur (vol de session).

.Gestion des sessions et OWASP Top 10
Le "Broken Access Control" (Contr√¥le d'acc√®s d√©faillant) est la menace n¬∞1 de l'OWASP 2021. Une mauvaise gestion de session m√®ne directement √† :
* **√âl√©vation de privil√®ge** (passer d'utilisateur √† admin).
* **Acc√®s au compte d‚Äôun tiers** (vol de session).
* **Bypass du m√©canisme de contr√¥le d‚Äôacc√®s**.

.Synth√®se des menaces (OWASP Session Management Cheat Sheet)
Pour s√©curiser les sessions, il faut se d√©fendre contre :
* **La pr√©diction d'ID de session :** Si l'ID est "1", "2", "3", un attaquant peut deviner. (Notre `secret` long et al√©atoire emp√™che cela).
* **Le vol de session (Session Hijacking) :** Intercepter le cookie (via une attaque XSS ou en √©coutant un r√©seau Wi-Fi non chiffr√©). (Les flags `httpOnly` et `secure` aident √† mitiger cela).
* **La fixation de session :** L'attaquant force un utilisateur √† utiliser un ID de session qu'il conna√Æt.

== Bonus : Architectures d'Authentification (Sch√©mas)

[NOTE]
.Rappel sur les architectures d'authentification
====
Voici un tableau r√©capitulatif des diff√©rentes m√©thodes que nous allons aborder. Comprendre leurs diff√©rences fondamentales (avec ou sans √©tat) est crucial.
====

[cols="1,2,1,2,a", options="header"]
|===
| Sch√©ma | Principe de base | Analogie | Flux (tr√®s simplifi√©) | Illustration

| Session (Stateful)
| Le serveur stocke tout (√©tat) et donne un simple ID (cookie) au client.
| üéüÔ∏è Ticket de vestiaire
| 1. Login/Pass -> 2. Serveur cr√©e session, stocke donn√©es, renvoie session-id (cookie). -> 3. Client envoie session-id √† chaque requ√™te. -> 4. Serveur v√©rifie l'ID dans son "vestiaire" (BDD/m√©moire).
| image::schema-session.png[Sch√©ma Session Stateful, width=200]

| JWT (Stateless)
| Le serveur ne stocke rien (sans √©tat). Le client poss√®de un jeton auto-suffisant et sign√©.
| üõÇ Passeport / Badge VIP
| 1. Login/Pass -> 2. Serveur cr√©e, signe et renvoie un JWT (ex: {"userId": 123}). -> 3. Client stocke le JWT et l'envoie √† chaque requ√™te (Header Authorization). -> 4. Serveur v√©rifie la signature du JWT (pas de BDD requise pour valider).
| image::schema-jwt.png[Sch√©ma JWT Stateless, width=200]

| OAuth2 (D√©l√©gation)
| N'est pas de l'authentification, mais de l'autorisation. Permet √† une app d'agir au nom d'un utilisateur sans son mot de passe.
| üîë Double de cl√© (limit√©)
| 1. App A demande √† App B (ex: Google) un acc√®s. -> 2. App B demande √† l'utilisateur : "Autoriser App A ?". -> 3. L'utilisateur dit "Oui". -> 4. App B donne un jeton d'acc√®s (limit√©) √† App A.
| image::schema-oauth2.png[Sch√©ma OAuth2, width=200]

| FIDO2 / WebAuthn (Passkeys)
| Authentification sans mot de passe, bas√©e sur la cryptographie (cl√© publique/priv√©e).
| üîí Cl√© physique / Biom√©trie
| 1. Enregistrement : L'appareil cr√©e une cl√© priv√©e (secr√®te) et envoie la cl√© publique au serveur. -> 2. Login : Le serveur envoie un d√©fi. -> 3. L'appareil signe le d√©fi avec la cl√© priv√©e (prot√©g√©e par biom√©trie). -> 4. Serveur v√©rifie la signature avec la cl√© publique.
| image::schema-fido2.png[Sch√©ma FIDO2, width=200]
|===

== Annexe : Diagramme de S√©quence d'une Session

image:img.png[Diagramme de s√©quence d'une session, width=700]