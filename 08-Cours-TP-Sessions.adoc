= TP - Authentification Web I : Gestion des Sessions
:author: Timoth√©e Robert
:revdate: 2025-11-09
:version-label: Version ESM, revue et am√©lior√©e
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js
:imagesdir: images

== Introduction

Nous avons vu comment authentifier un utilisateur avec un mot de passe hach√© et sal√©.  Cependant, le protocole **HTTP est "stateless"** (sans √©tat). Une fois l'authentification r√©ussie sur une requ√™te, le serveur "oublie" l'utilisateur pour la requ√™te suivante.

Comment, d√®s lors, donner acc√®s √† des ressources prot√©g√©es sans redemander le mot de passe √† chaque clic ?

C'est le r√¥le de la **gestion de session**. Aujourd'hui, nous √©tudions le m√©canisme de session web "classique" (stateful). Par la suite, nous aborderons les tokens (JWT), OAuth2, et l'authentification √† double facteur.

[NOTE]
.Complexit√© des m√©thodes d'authentification
====
image::modesAuth.png[Tableau des choix d'authentification]

Comme le montre ce sch√©ma, la gestion de session est le point de d√©part, et la complexit√© augmente avec des solutions comme JWT ou OAuth.
====

=== Analyse pr√©liminaire

.Question de recherche :
Pourquoi les cookies "simples" (contenant directement des informations utilisateur) et les param√®tres d'une requ√™te GET (ex: `?user=tim&role=admin`) ne sont-ils **absolument pas** appropri√©s pour g√©rer une authentification ?

== Fonctionnement d'une session HTTP

=== Principes

HTTP est sans √©tat, mais on peut utiliser ses en-t√™tes (`headers`) et les **cookies** pour simuler un √©tat.

* **En-t√™tes (Headers) :** Informations de m√©tadonn√©es qui voyagent avec chaque requ√™te et r√©ponse.
* **Cookies :** Petits morceaux de donn√©es que le serveur demande au client (navigateur) de stocker.

Le flux de base est le suivant :

image::sessionsCookies.png[Flux de session HTTP]

1.  Le client demande une page.
2.  Le serveur, dans sa r√©ponse, inclut un en-t√™te `Set-Cookie: session-id=12345;`. Le navigateur stocke ce cookie.
3.  Pour toutes les requ√™tes suivantes vers *le m√™me domaine*, le navigateur inclut automatiquement un en-t√™te `Cookie: session-id=12345;`.
4.  Le serveur lit cet ID, recherche la session "12345" dans sa base de donn√©es et "sait" ainsi qui est l'utilisateur.


=== Exercice : Examen d'un cookie

.  Dans Chrome, allez sur une page (ex: google.fr) et ouvrez la console (F12).
.  Dans la console, tapez le code suivant :
+
[source,javascript]
----
const maDate = new Date();
// Ajoute 30000 millisecondes (30 secondes) √† la date actuelle
maDate.setTime(maDate.getTime() + 30000);
// Cr√©e un cookie c√¥t√© client
document.cookie = "monCookie=Totoro; expires=" + maDate.toUTCString() + ";";
----
+
.  *Analyse :*
.. Que fait ce code ?
.. Allez dans l'onglet `Application` -> `Stockage` -> `Cookies`. Que constatez-vous ?
.. Combien de temps avez-vous pour voir ce cookie avant qu'il ne disparaisse ?
.  *Visualisation (optionnel) :*
.. Rechargez la page (F5) et allez dans l'onglet `R√©seau (Network)`.
.. Cliquez sur la premi√®re requ√™te (le nom de la page).
.. Dans les en-t√™tes (`Headers`), cherchez `Cookie` dans la section `Request Headers`. Vous devriez y voir votre cookie "monCookie=Totoro" √™tre envoy√© au serveur.

=== Donn√©es de session

La diff√©rence fondamentale est simple :

* Le **cookie** est stock√© **c√¥t√© client** (navigateur).
* Les **donn√©es de session** (qui est l'utilisateur, son r√¥le, etc.) sont stock√©es **c√¥t√© serveur** (en m√©moire, dans un fichier, ou en BDD).

Le cookie de session ne contient qu'un **identifiant al√©atoire et d√©nu√© de sens** (le `session-id`). Il sert uniquement de "cl√©" pour retrouver les vraies donn√©es c√¥t√© serveur. C'est pour cela que ce m√©canisme est dit **"stateful"** (le serveur maintient un √©tat).

=== Authentification vs. Autorisation

.Question de cours :
Rappelez en une phrase la diff√©rence fondamentale entre **l'authentification** et **l'autorisation**.

[TIP]
.R√©ponse
====
* **Authentification** : Prouver qui vous √™tes (ex: login + mot de passe). C'est le "contr√¥le d'identit√©".
* **Autorisation** : V√©rifier ce que vous avez le droit de faire (ex: un "admin" peut voir le panel, un "user" ne peut pas). Ce sont les "permissions".
====

=== Exercice : Utilisation de cURL (Challenge)

Cet exercice (bas√© sur un challenge PHP) d√©montre parfaitement la persistance de session.

.  Installez les deux fichiers PHP (`session.php` et `supprime.php`), fournis dans le r√©pertoire sources, dans votre r√©pertoire `www` de Laragon.
.  D√©marrez Laragon.
.  Avec votre navigateur, visitez les URL dans cet ordre :
.. `http://localhost/session.php` (Affiche "Je ne sais pas qui vous √™tes")
.. `http://localhost/session.php?nom=Django` (Affiche "Je sais que vous vous appelez Django")
.. `http://localhost/session.php` (Affiche "Je sais que vous vous appelez Django")
.  Le serveur se "souvient" de vous gr√¢ce √† la session.
.  **Votre challenge :** Reproduisez ce sc√©nario exact en ligne de commande avec `cURL`. (Indice : `cURL` ne sauvegarde pas les cookies par d√©faut, il faudra utiliser les options `-c` (cookie-jar) et `-b` (cookie) pour simuler le navigateur).

== Partie 2 : Impl√©mentation avec NodeJS et `express-session`

Nous allons impl√©menter ce m√©canisme dans notre application d'authentification.

=== √âtape 1 : Installation

Nous avons besoin de `express-session` pour g√©rer les sessions.

[source,bash]
----
# express-session g√®re la session
# connect-session-file-store (optionnel) pour stocker les sessions dans des fichiers
npm install express-session session-file-store
----

[NOTE]
.Nettoyage des d√©pendances
====
Dans le document original (ann√©e derni√®re), `cookie-parser` et `body-parser` √©taient list√©s.

* `body-parser` est **obsol√®te**. `express.json()` et `express.urlencoded()` sont int√©gr√©s √† Express.
* `cookie-parser` n'est **plus n√©cessaire** pour `express-session` depuis la version 1.5.0. La librairie g√®re les cookies elle-m√™me.
====

=== √âtape 2 : D√©marrage express (100% ESM)

Voici le code de d√©marrage d'un `server.js` 100% ESM, nettoy√© et corrig√©.

[source,javascript]
----
// --- Imports des modules ---
import express from 'express';
import session from 'express-session';
// import mysql from 'mysql2'; // Plus tard, pour stocker en BDD
import path from 'path';

// --- Imports de nos modules (du TP pr√©c√©dent) ---
// import { verifieMdp } from './verifieMdp.mjs';
// import { sha512 } from './hashPassword.mjs';

// --- Configuration initiale ---
const app = express();
const port = 3000;

// Syntaxe ESM moderne pour __dirname
const __dirname = import.meta.dirname;

// --- Middlewares ---
app.use(express.json()); // Pour parser le JSON
app.use(express.urlencoded({ extended: true })); // Pour parser les formulaires
app.use(express.static(path.join(__dirname, 'static'))); // Servir les fichiers statiques (CSS, etc.)
----

=== √âtape 3 : Cr√©ation et configuration de la session

Nous ajoutons `express-session` comme un middleware. Il doit √™tre plac√© **avant** toutes les routes qui en ont besoin.

[source,javascript]
----
// ... (suite du server.js) ...

app.use(session({
  // 'secret' est utilis√© pour signer le cookie de session
  // NE PAS le hardcoder en production !
  secret: 'les SIO font toujours dodo',

  // 'name' est le nom du cookie
  name: 'monCookieDeSession',

  // Ne pas sauvegarder la session si elle n'est pas modifi√©e
  resave: false,

  // Ne pas cr√©er de session pour un utilisateur non-authentifi√©
  saveUninitialized: false,

  cookie: {
    // Le cookie ne sera pas accessible par le JS c√¥t√© client
    httpOnly: true,
    // Mettre 'true' en production (n√©cessite HTTPS)
    secure: false,
    // Dur√©e de vie du cookie (ex: 30 secondes pour tester)
    maxAge: 30000
  }
}));

// --- D√©marrage du serveur ---
app.listen(port, () => {
  console.log(`Serveur d√©marr√© sur http://localhost:${port}`);
});
----

[IMPORTANT]
.Critiques de S√©curit√© et Bonnes Pratiques
====
1.  **Secret :** Le `secret` hardcod√© est une faille de s√©curit√©. S'il est d√©couvert, un attaquant peut forger des ID de session. Ce secret DOIT provenir d'un fichier `.env` et √™tre long et al√©atoire (`process.env.SESSION_SECRET`).
2.  **`resave: false` :** Tr√®s bonne pratique. Cela √©vite de r√©-enregistrer la session en BDD √† chaque requ√™te si rien n'a chang√©.
3.  **`saveUninitialized: false` :** Tr√®s bonne pratique. Cela √©vite de polluer le stockage de sessions avec des sessions vides pour les visiteurs anonymes (important pour le RGPD).
4.  **`cookie.secure: true` :** Doit √™tre mis √† `true` en production. Cela force le cookie √† n'√™tre envoy√© que sur une connexion HTTPS, emp√™chant son interception.
5.  **Stockage M√©moire :** Par d√©faut, `express-session` stocke les sessions en m√©moire vive. C'est mauvais pour la production :
* Les sessions sont perdues √† chaque red√©marrage du serveur.
* Cela ne fonctionne pas si vous avez plusieurs serveurs (load balancing).
* Cela peut saturer la m√©moire (fuite de m√©moire).
====

=== √âtape 4 : Analyse et utilisation de la session

Une fois le middleware `session` activ√©, un objet `req.session` est **automatiquement ajout√©** √† chaque requ√™te. Nous pouvons lire et √©crire des donn√©es dedans.

[source,javascript]
----
// ... (√† ajouter avant app.listen) ...

app.get('/compteur', (requete, resultat) => {
  // On v√©rifie si la propri√©t√© 'compteur' existe dans la session
  // Si non, on l'initialise √† 0. Puis on l'incr√©mente.
  requete.session.compteur = (requete.session.compteur || 0) + 1;

  // On peut lire l'ID de session
  const idSession = requete.sessionID;

  // On peut lire les cookies
  console.log(requete.cookies); // Affiche les cookies non-sign√©s

  resultat.send(`
    <h1>Bonjour les rigolos</h1>
    <p>Vous √™tes venus ${requete.session.compteur} fois.</p>
    <p>Votre ID de session est : ${idSession}</p>
  `);
});
----

[TIP]
.Am√©lioration du code
====
La ligne :
`requete.session.compteur = (requete.session.compteur || 0) + 1;`
...est une mani√®re idiomatique et concise d'initialiser et d'incr√©menter un compteur en JavaScript.
====

=== √âtape 5 : Destruction d'une session

Pour d√©connecter un utilisateur, on utilise `req.session.destroy()`.

[source,javascript]
----
app.get('/logout', (requete, resultat) => {
  requete.session.destroy((err) => {
    if (err) {
      return resultat.send("Erreur lors de la d√©connexion");
    }
    // Optionnel : effacer le cookie c√¥t√© client
    resultat.clearCookie('monCookieDeSession');
    resultat.send("Session d√©truite !");
  });
});
----

=== √Ä faire (Exercice final)

1.  Int√©grez ce code dans votre projet d'authentification (de la s√©ance pr√©c√©dente).
2.  Modifiez la route `POST /login` : si l'authentification (`argon2.verify` ou `sha512`) r√©ussit, **n'affichez pas** "Bienvenue", mais :
* Stockez l'ID de l'utilisateur dans la session (ex: `req.session.userId = utilisateur.id`).
* Redirigez l'utilisateur vers une nouvelle page (ex: `res.redirect('/profil')`).
3.  Cr√©ez une nouvelle route `GET /profil`.
4.  Dans cette route `/profil`, v√©rifiez si `req.session.userId` existe.
* Si **oui**, r√©cup√©rez les infos de l'utilisateur en BDD et affichez "Bienvenue [NomUtilisateur]".
* Si **non** (l'utilisateur n'est pas connect√©), redirigez-le vers la page de login (`res.redirect('/login')`).
5.  Impl√©mentez la route `GET /logout` qui d√©truit la session et redirige vers `/login`.

== Bonus : Architectures d'Authentification (Sch√©mas)

Pr√©cisions sur les diff√©rents sch√©mas d'authentification (Session, JWT, OAuth, FIDO2) avec analogies et flux.

[NOTE]
.Synth√®se sur les architectures d'authentification
====
Avant de commencer, voici un tableau r√©capitulatif des diff√©rentes m√©thodes que nous allons aborder. Comprendre leurs diff√©rences fondamentales (avec ou sans √©tat) est crucial.
====

[cols="1,2,1,2", options="header"]
|===
| Sch√©ma | Principe de base | Analogie | Flux (tr√®s simplifi√©)

| Session (Stateful)
| Le serveur stocke tout (√©tat) et donne un simple ID (cookie) au client.
| üéüÔ∏è Ticket de vestiaire
| 1. Login/Pass -> 2. Serveur cr√©e session, stocke donn√©es, renvoie session-id (cookie). -> 3. Client envoie session-id √† chaque requ√™te. -> 4. Serveur v√©rifie l'ID dans son "vestiaire" (BDD/m√©moire).

| JWT (Stateless)
| Le serveur ne stocke rien (sans √©tat). Le client poss√®de un jeton auto-suffisant et sign√©.
| üõÇ Passeport / Badge VIP
| 1. Login/Pass -> 2. Serveur cr√©e, signe et renvoie un JWT (ex: {"userId": 123}). -> 3. Client stocke le JWT et l'envoie √† chaque requ√™te (Header Authorization). -> 4. Serveur v√©rifie la signature du JWT (pas de BDD requise pour valider).

| OAuth2 (D√©l√©gation)
| N'est pas de l'authentification, mais de l'autorisation. Permet √† une app d'agir au nom d'un utilisateur sans son mot de passe.
| üîë Double de cl√© (limit√©)
| 1. App A demande √† App B (ex: Google) un acc√®s. -> 2. App B demande √† l'utilisateur : "Autoriser App A ?". -> 3. L'utilisateur dit "Oui". -> 4. App B donne un jeton d'acc√®s (limit√©) √† App A.

| FIDO2 / WebAuthn (Passkeys)
| Authentification sans mot de passe, bas√©e sur la cryptographie (cl√© publique/priv√©e).
| üîí Cl√© physique / Biom√©trie
| 1. Enregistrement : L'appareil cr√©e une cl√© priv√©e (secr√®te) et envoie la cl√© publique au serveur. -> 2. Login : Le serveur envoie un d√©fi. -> 3. L'appareil signe le d√©fi avec la cl√© priv√©e (prot√©g√©e par biom√©trie). -> 4. Serveur v√©rifie la signature avec la cl√© publique.
|===



### 1. Session Standard (Stateful)
* **Ce que c'est :** Ce que nous venons de faire. Le serveur cr√©e un ID de session, le stocke (en BDD/m√©moire) et envoie l'ID au client dans un cookie.
* **Analogie :** C'est un ticket de *vestiaire*.
* **Flux :**
1.  Vous donnez votre manteau (login/pass).
2.  Le vestiaire garde votre manteau (donn√©es de session) et vous donne un ticket (cookie `session-id`).
3.  √Ä chaque fois que vous voulez votre chapeau (une ressource), vous montrez votre ticket. Le serveur v√©rifie dans son vestiaire et vous donne ce qui vous appartient.


### 2. JSON Web Token (JWT) (Stateless)
* **Ce que c'est :** Le serveur ne stocke *rien*. Il donne au client un "jeton" (le JWT) qui contient les informations de l'utilisateur (ex: `{"userId": 123, "role": "admin"}`) sign√©es cryptographiquement.
* **Analogie :** C'est un *badge VIP* ou un passeport.
* **Flux :**
1.  Vous prouvez votre identit√© (login/pass).
2.  Le serveur vous donne un badge VIP scell√© et infalsifiable (le JWT) qui dit "Cette personne est un admin".
3.  √Ä chaque fois que vous voulez acc√©der √† une zone, vous montrez votre badge. Le videur (serveur) v√©rifie juste la signature (le sceau) du badge. Il n'a pas besoin de v√©rifier une liste ou un vestiaire.


### 3. OAuth2 (D√©l√©gation)
* **Ce que c'est :** Ce n'est *pas* de l'authentification, mais de **l'autorisation d√©l√©gu√©e**. C'est ce qui g√®re le "Se connecter avec Google / Facebook".
* **Analogie :** C'est un *double de cl√© limit√©*.
* **Flux :**
1.  Vous √™tes sur `un-site-random.com` et cliquez sur "Se connecter avec Google".
2.  Le site vous redirige vers Google, qui vous demande : "Acceptez-vous que `un-site-random.com` acc√®de √† votre email et votre nom ?".
3.  Vous dites "Oui".
4.  Google ne donne *pas* votre mot de passe √† `un-site-random.com`. Il lui donne un *jeton sp√©cial* (un jeton OAuth) qui dit "J'ai v√©rifi√© cet utilisateur, et je t'autorise √† voir son email".


### 4. FIDO2 / WebAuthn (Authentification)
* **Ce que c'est :** Une m√©thode d'authentification *sans mot de passe* bas√©e sur la cryptographie √† cl√© publique/priv√©e. Utilise des dispositifs physiques (cl√© USB, biom√©trie).
* **Analogie :** C'est une *cl√© physique* ou votre *empreinte digitale*.
* **Flux :**
1.  Lors de l'inscription, votre appareil cr√©e une paire de cl√©s (publique/priv√©e). La cl√© publique est envoy√©e au serveur, la cl√© priv√©e reste sur votre appareil.
2.  Lors de la connexion, le serveur envoie un d√©fi (challenge) √† votre appareil.