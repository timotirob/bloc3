= TP - Persistance des Données avec NodeJS et une Base de Données
:author: Timothée Robert
:revdate: 2025-10-03
:version-label: Version ESM
:toc: left
:toclevels: 3
:sectnums:
:source-highlighter: highlight.js
:imagesdir: images

[IMPORTANT]
.Note sur ce TP
====
Ce TP fait suite à nos travaux sur Express et les middlewares. Nous abordons maintenant la persistance des données, c'est-à-dire comment sauvegarder et lire des informations dans une base de données MySQL. Tout le code est présenté en utilisant la syntaxe **ES Modules (ESM)**.
====

== Introduction

Après avoir exploré les routes et les middlewares avec Express, nous allons nous pencher sur une brique essentielle de toute application : la **persistance des données**. Nous verrons comment connecter notre application NodeJS à une base de données MySQL de deux manières :

1.  **Accès direct** avec la librairie `mysql2`.
2.  **Via un ORM (Object-Relational Mapping)** avec la librairie `Sequelize`.

Cela nous permettra d'aborder sereinement les problématiques de Cybersécurité (authentification, sessions, etc.) qui reposent sur le stockage d'informations.

== Partie 1 : Accès à une base de données SQL

Nous allons mettre en place une application NodeJS capable de communiquer avec une base de données MySQL.

=== Étape 1 : Préparation de l'environnement

. *Nouveau fichier :* Créez un fichier `database.js` dans votre projet.
. *Installation des packages :* Nous avons besoin de la librairie `mysql2` pour interagir avec MySQL.
+
[source,bash]
----
npm install mysql2
----
+
[NOTE]
====
Nous utilisons `mysql2` car elle est plus performante que l'ancienne librairie `mysql` et supporte nativement les **Promesses**, ce qui est idéal pour la syntaxe moderne `async/await`.
====
. *Création de la base de données :* Dans votre SGBD MySQL, créez une nouvelle base de données. Nommons-la `nodemysql` pour l'exemple.
. *Création de la table et des données :* Exécutez le script SQL suivant dans votre base `nodemysql` pour créer et peupler la table `eleves`.
+
.Création Table Eleves.sql
[source,sql]
----
CREATE TABLE IF NOT EXISTS `eleves` (
  `ID` int NOT NULL AUTO_INCREMENT,
  `NOM` varchar(100) DEFAULT NULL,
  `PRENOM` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`ID`)
);

INSERT INTO `eleves` (`ID`, `NOM`, `PRENOM`) VALUES
	(1, 'Abbas', 'Franck'),
	(2, 'Barriaud', 'Noemie'),
	(3, 'Bendjebbour', 'Ines'),
	(4, 'Bangoura', 'Fode'),
	(5, 'Lopes', 'Loretta'),
	(6, 'Dupond', 'Paul'),
	(7, 'Robert', 'Tim'),
	(8, 'Robert', 'Tommy'),
	(9, 'Totoro', 'Le gentil');
----

=== Étape 2 : Connexion et sélection de données

Dans votre fichier `database.js`, nous allons écrire un script simple pour nous connecter et lire les données de la table `eleves`.

.database.js (connexion et lecture)
[source,javascript]
----
// On importe la librairie mysql2 en mode ESM
import mysql from 'mysql2/promise';

// On englobe notre code dans une fonction asynchrone pour pouvoir utiliser 'await'
async function main() {
  let connection;
  try {
    // 1. Définition et création de la connexion
    // Adaptez les identifiants à votre configuration locale
    connection = await mysql.createConnection({
      host: 'localhost',
      user: 'root',
      password: '', // Ajoutez votre mot de passe si vous en avez un
      database: 'nodemysql'
    });

    // 2. Récupération des données
    const [lignes, colonnes] = await connection.execute('SELECT * FROM eleves');

    // 3. Affichage dans la console
    console.log("--- Lignes de données ---");
    console.log(lignes);
    console.log("\n--- Informations sur les colonnes ---");
    console.log(colonnes);

  } catch (error) {
    console.error('Erreur de connexion ou de requête :', error);
  } finally {
    // 4. On s'assure de bien fermer la connexion à la fin
    if (connection) {
      connection.end();
    }
  }
}

// On exécute notre fonction principale
main();
----

=== Exercice 1 : Test de la connexion

. Reproduisez les étapes ci-dessus dans votre projet.
. Lancez le script avec `node database.js`.
. Expliquez ce qui s'affiche dans la console pour les `lignes` et pour les `colonnes`.

[TIP]
.Explication des résultats
====
* `lignes` : C'est un tableau d'objets JavaScript. Chaque objet représente une ligne de la table `eleves`, où les clés sont les noms des colonnes (`ID`, `NOM`, `PRENOM`).
* `colonnes` : C'est un tableau contenant des métadonnées sur les champs de la table (type, longueur, etc.).
====

=== Exercice 2 (Optionnel) : Insertion de données via un formulaire

Maintenant, nous allons combiner cela avec Express pour insérer un nouvel élève depuis un formulaire HTML.

. *Prérequis :* Installez Express si ce n'est pas déjà fait (`npm install express`).
. *Structure du code :* Modifiez votre `database.js` pour y intégrer un serveur Express.
. *Formulaire HTML :* Créez un fichier `public/ajoutEleve.html`.
+
[source,html]
----
<!DOCTYPE html>
<html lang="fr">
<head><title>Ajouter un élève</title></head>
<body>
    <form action="/ajouter" method="post">
        <input type="text" name="nom" placeholder="Nom de l'élève" required>
        <input type="text" name="prenom" placeholder="Prénom de l'élève" required>
        <button type="submit">Ajouter</button>
    </form>
</body>
</html>
----
+
. *Code serveur complet (`database.js`)*
+
[source,javascript]
----
import express from 'express';
import mysql from 'mysql2/promise';
import path from 'path';
const __dirname = import.meta.dirname; // Syntaxe moderne pour __dirname

const app = express();
const port = 3000;

// Middleware pour parser le corps des requêtes de formulaire
app.use(express.urlencoded({ extended: true }));

// Configuration de la connexion (à sortir dans une fonction pour être réutilisable)
const dbConfig = {
  host: 'localhost',
  user: 'root',
  password: '',
  database: 'nodemysql'
};

// Route GET pour afficher le formulaire
app.get('/formulaire', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/ajoutEleve.html'));
});

// Route POST pour traiter les données du formulaire
app.post('/ajouter', async (req, res) => {
  const { nom, prenom } = req.body; // Récupère nom et prenom du formulaire
  const nouvelEleve = { NOM: nom, PRENOM: prenom };

  let connection;
  try {
    connection = await mysql.createConnection(dbConfig);
    const sql = 'INSERT INTO eleves SET ?';

    // Le '?' est un placeholder. mysql2 le remplace de manière sécurisée par l'objet nouvelEleve
    await connection.query(sql, nouvelEleve);

    res.send(`Élève ${prenom} ${nom} ajouté avec succès !`);
  } catch (error) {
    console.error("Erreur lors de l'insertion :", error);
    res.status(500).send("Erreur serveur lors de l'ajout de l'élève.");
  } finally {
    if (connection) connection.end();
  }
});

app.listen(port, () => {
  console.log(`Serveur démarré sur http://localhost:${port}`);
});
----

== Partie 2 : Utilisation d'un ORM avec Sequelize

=== Introduction

Un **ORM (Object-Relational Mapping)** est un outil qui crée une "couche d'abstraction" entre le code orienté objet (nos classes et objets JavaScript) et la base de données relationnelle (nos tables SQL). Au lieu d'écrire du SQL, on manipule des objets, et l'ORM se charge de la traduction.

Nous allons utiliser **Sequelize**, l'un des ORM les plus populaires de l'écosystème NodeJS.

=== Étape 1 : Installation et configuration

. *Installation :* Sequelize a besoin de son propre package ainsi que du driver de la base de données (`mysql2` que nous avons déjà).
+
[source,bash]
----
npm install sequelize
----
+
. *Nouveau Fichier :* Créez un fichier `orm.js`.
. *Connexion :* La connexion avec Sequelize est très similaire.
+
[source,javascript]
----
import { Sequelize, DataTypes } from 'sequelize';

// 1. Initialisation de Sequelize
const sequelize = new Sequelize('nodemysql', 'root', '', {
  host: 'localhost',
  dialect: 'mysql' // Très important de spécifier le SGBD
});

// 2. Test de la connexion (utilise les Promesses)
sequelize.authenticate()
  .then(() => {
    console.log('La connexion à la BDD est correcte.');
  })
  .catch((erreur) => {
    console.error('Impossible de se connecter à la BDD:', erreur);
  });
----

=== Étape 2 : Définir un modèle et insérer des données

Avec un ORM, une table est représentée par une classe appelée "Modèle".

.orm.js (suite)
[source,javascript]
----
// ... (code de connexion de l'étape 1) ...

// 3. Définition du modèle "Notes"
// Sequelize créera une table nommée 'notes_eleves'
const Notes = sequelize.define('notes_eleves', {
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  note: {
    type: DataTypes.FLOAT,
    allowNull: false // La note ne peut pas être vide
  },
  date_eval: {
    type: DataTypes.DATEONLY
  }
});

// 4. Synchronisation et insertion
// .sync() crée la table si elle n'existe pas
sequelize.sync().then(async () => {
  console.log('Table "notes_eleves" créée avec succès !');

  try {
    // On utilise la méthode .create() du modèle pour insérer une ligne
    const noteTim = await Notes.create({
      note: 12.5,
      date_eval: new Date(2025, 9, 9), // mois 9 = Octobre en JS
    });

    console.log('Note insérée :', noteTim.toJSON());
  } catch (erreur) {
    console.error('Impossible d\'insérer la note :', erreur);
  }

}).catch((erreur) => {
  console.error('Impossible de créer la table :', erreur);
});
----

=== Exercice 3 : Utilisation de Sequelize

. Reproduisez l'exemple complet de `orm.js` et exécutez-le.
. Quel code est responsable de la création de la table (`CREATE TABLE`) ? Et de son application à la BDD (la "migration") ?
. Quel code permet d'insérer une nouvelle `Note` dans la table ?
. Cherchez et donnez une définition simple d'une **Promesse (Promise)** en JavaScript. Quels sont ses trois états possibles ?
. Le code ci-dessus gère-t-il les erreurs ? Si oui, où ?
. Si vous exécutez le programme une deuxième fois, que se passe-t-il ? Le programme fonctionne-t-il toujours ? Pourquoi ?

=== Exercice 4 (Optionnel et avancé) : Modèle avancé et relations

. *Améliorer le modèle :* Modifiez le modèle `Notes` pour y ajouter les champs suivants :
** `coeff` (FLOAT, non nul)
** `matiere` (STRING)
** `appreciation` (TEXT)
. *Relation :* Cherchez dans la documentation de Sequelize comment créer une relation "un-à-plusieurs" entre un `Eleve` (qu'il faudra aussi modéliser) et ses `Notes`.
. *Formulaire :* Créez une application Express complète qui permet de sélectionner un élève dans une liste déroulante et de lui ajouter une note via un formulaire.